#8.自动化特征提取器：图像特征提取和深度学习

视觉和声音是人类固有的感觉输入。我们的大脑是可以迅速进化我们的能力来处理视觉和听觉信号的，一些系统甚至在出生前就对刺激做出反应。另一方面，语言技能是学习得来的。他们需要几个月或几年的时间来掌握。许多人天生就具有视力和听力的天赋，但是我们所有人都必须有意训练我们的大脑去理解和使用语言。

有趣的是，机器学习的情况是相反的。我们已经在文本分析应用方面取得了比图像或音频更多的进展。以搜索问题为例。人们在信息检索和文本检索方面已经取得了相当多年的成功，而图像和音频搜索仍在不断完善。在过去五年中，深度学习模式的突破最终预示着期待已久的图像和语音分析的革命。

进展的困难与从相应类型的数据中提取有意义特征的困难直接相关。机器学习模型需要语义上有意义的特征进行语义意义的预测。在文本分析中，特别是对于英语这样的语言，其中一个基本的语义单位（一个词）很容易提取，可以很快地取得进展。另一方面，图像和音频被记录为数字像素或波形。图像中的单个“原子”是像素。在音频数据中，它是波形强度的单一测量。它们包含的语义信息远少于数据文本。因此，在图像和音频上的特征提取和工程任务比文本更具挑战性。

在过去的二十年中，计算机视觉研究已经集中在人工标定上，用于提取良好的图像特征。在一段时间内，图像特征提取器，如SIFT和HOG是标准步骤。深度学习研究的最新发展已经扩展了传统机器学习模型的范围，将自动特征提取作为基础层。他们本质上取代手动定义的特征图像提取器与手动定义的模型，自动学习和提取特征。人工标定仍然存在，只是进一步深入到建模中去。

在本章中，我们将从流行的图像特征提取SIFT和HOG入手，深入研究本书所涵盖的最复杂的建模机制：深度学习的特征工程。

##最简单的图像特征（为什么他们不好使）

从图像中提取的哪些特征是正确的呢？答案当然取决于我们试图用这些特征来做什么。假设我们的任务是图像检索：我们得到一张图片并要求从图像数据库中得到相似的图片。我们需要决定如何表示每个图像，以及如何测量它们之间的差异。我们可以看看图像中不同颜色的百分比吗？图8-1展示了两幅具有大致相同颜色轮廓但有着非常不同含义的图片；一个看起来像蓝色天空中的白云，另一个是希腊国旗。因此，颜色信息可能不足以表征图像。

![图8-1](../images/chapter_8/8-1.png)

另一个比较简单的想法是测量图像之间的像素值差异。首先，调整图像的宽度和高度。每个图像由像素值矩阵表示。矩阵可以通过一行或一列被堆叠成一个长向量。每个像素的颜色（例如，颜色的RGB编码）现在是图像的特征。最后，测量长像素向量之间的欧几里得距离。这绝对可以区分希腊国旗和白云。但作为相似性度量，它过于严格。云可以呈现一千种不同的形状，仍然是一朵云。它可以移动到图像的一边，或者一半可能位于阴影中。所有这些转换都会增加欧几里得距离，但是他们不应该改变图片仍然是云的事实。

问题是单个像素不携带足够的图像语义信息。因此，使用它们用于分析结果是非常糟糕的。在1999年，计算机视觉研究者想出了一种更好的方法来使用图像的统计数据来表示图像。它叫做Scale Invariant Feature Transform （SIFT）。

SIFT最初是为对象识别的任务而开发的，它不仅涉及将图像正确地标记为包含对象，而且确定其在图像中的位置。该过程包括在可能的尺度金字塔上分析图像，检测可以指示对象存在的兴趣点，提取关于兴趣点的特征（通常称为计算机视觉中的图像描述符），并确定对象的姿态。

多年来，SIFT的使用扩展到不仅提取兴趣点，而且遍及整个图像的特征。SIFT特征提取过程非常类似于另一种称为 Histogram of Oriented Gradients （HOG）的技术。它们都计算梯度方向的直方图。现在我们详细地描述一下。

##人工特征提取：SIFT与HOG

###图像梯度



![图8-2](../images/chapter_8/8-2.png)


```python
from mpl_toolkits.mplot3d import Axes3D 
from sklearn import manifold, datasets 
 
# 在瑞士卷训练集上产生噪声
X, color = datasets.samples_generator.make_swiss_roll(n_samples=1500) 
 
# 用100 K-均值聚类估计数据集 
clusters_swiss_roll = KMeans(n_clusters=100, random_state=1).fit_predict(X) 
 
# 展示用数据集，其中颜色是K-均值聚类的id
fig2 = plt.figure() ax = fig2.add_subplot(111, projection='3d') 
ax.scatter(X[:, 0], X[:, 1], X[:, 2], c=clusters_swiss_roll, cmap='Spectral') 
```













































